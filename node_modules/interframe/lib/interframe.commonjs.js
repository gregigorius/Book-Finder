/*! interframe v2.2.0 by Sebastian Fastner <s.fastner@sebastian-software.de> */
'use strict';

var id = 0;
function nextID() {
  id += 1;
  return id;
}

var TYPE = "application/interframe-ssoft-v1+json",
    PROMISE_TIMEOUT = 3e3,
    HAS_CONSOLE_LOG = typeof console != "undefined" && typeof console.log == "function",
    UNIQUE_ID_RANDOM_LENGTH = 5;

function log(id) {
  if (HAS_CONSOLE_LOG) {
    for (var _console, _len = arguments.length, messages = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      messages[_key - 1] = arguments[_key];
    }

    (_console = console).log.apply(_console, ["[interframe " + id + "]"].concat(messages));
  }
}

function generateUniqueId() {
  var nowDate = Date.now().toString();
  return nowDate.substring(nowDate.length - UNIQUE_ID_RANDOM_LENGTH) + "-" + Math.random().toFixed(UNIQUE_ID_RANDOM_LENGTH).substring(2);
}

function interframe(targetWindow, origin, sourceWindow, _temp) {
  if (origin === void 0) {
    origin = "*";
  }

  var _ref = _temp === void 0 ? {
    debug: false
  } : _temp,
      debug = _ref.debug;

  if (!targetWindow) {
    throw new Error("parameter 'targetWindow' is missing");
  }

  var ownId = generateUniqueId(),
      listeners = new Map(),
      handshakeCallback = new Set(),
      responseResolver = new Map(),
      preHandshakeSendQueue = new Set(),
      outstandingMessages = new Map(),
      isHandshaken = false;

  function send(namespace, data, responseId) {
    if (data === void 0) {
      data = null;
    }

    if (!namespace) {
      throw new Error("parameter 'namespace' is missing");
    }

    if (typeof namespace != "string") {
      throw new Error("parameter 'namespace' must be a string");
    }

    if (!isHandshaken) {
      if (debug) {
        log(ownId, "send() to " + namespace + " without handshake", data);
      }

      return new Promise(function (resolve) {
        preHandshakeSendQueue.add({
          namespace: namespace,
          data: data,
          responseId: responseId,
          resolve: resolve
        });
      });
    }

    if (debug) {
      log(ownId, "send() to " + namespace, data);
    }

    var id = nextID();

    if (origin !== null) {
      targetWindow.postMessage(JSON.stringify({
        id: id,
        responseId: responseId,
        type: TYPE,
        namespace: namespace,
        data: data
      }), origin);
    } else {
      targetWindow.postMessage(JSON.stringify({
        id: id,
        responseId: responseId,
        type: TYPE,
        namespace: namespace,
        data: data
      }));
    }

    return new Promise(function (resolve) {
      var timer = setTimeout(function () {
        responseResolver["delete"](id);
        resolve();
      }, PROMISE_TIMEOUT);
      responseResolver.set(id, {
        resolve: resolve,
        timer: timer
      });
    });
  }

  function sendHandshake(acknowledgement) {
    if (acknowledgement === void 0) {
      acknowledgement = false;
    }

    var message = {
      type: TYPE,
      handshakeConfirmation: !!acknowledgement,
      handshake: !acknowledgement
    };

    if (debug) {
      if (acknowledgement) {
        log(ownId, "sendHandshake() as acknowledgement to handshake request");
      } else {
        log(ownId, "sendHandshake() as initial handshake request");
      }
    }

    if (origin !== null) {
      targetWindow.postMessage(JSON.stringify(message), origin);
    } else {
      targetWindow.postMessage(JSON.stringify(message));
    }
  }

  function isSafeMessage(msgSource, msgOrigin, msgType) {
    var jsdom = window.navigator.userAgent.indexOf("jsdom") >= 0 && msgSource === null,
        safeOrigin = origin === "*" || origin === null || msgOrigin === origin;
    return (msgSource === targetWindow || jsdom) && safeOrigin && msgType === TYPE;
  }

  function handleHandshake(data) {
    if (data.handshake) sendHandshake(true);
    isHandshaken = true;
    handshakeCallback.forEach(function (hsCallback) {
      return hsCallback();
    });
    handshakeCallback.clear();
    preHandshakeSendQueue.forEach(function (sendItem) {
      return send(sendItem.namespace, sendItem.data, sendItem.responseId).then(function (response) {
        return sendItem.resolve(response);
      })["catch"](function () {
        return sendItem.resolve();
      });
    });
    preHandshakeSendQueue.clear();
  }

  var objectAssign = typeof Object.assign == "function" ? Object.assign : function objectAssignPolyfill(target) {
    for (var result = Object(target), index = 1, nextSource; index < arguments.length; index++) {
      nextSource = arguments[index];

      if (nextSource != null) {
        for (var nextKey in nextSource) {
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            result[nextKey] = nextSource[nextKey];
          }
        }
      }
    }

    return result;
  };

  function createMessage(messageData) {
    var message = {
      id: messageData.id,
      data: messageData.data,
      namespace: messageData.namespace,
      open: function open() {
        message.isPromise = true;
        return objectAssign({}, messageData, {
          response: function response(data) {
            send(messageData.namespace, data, messageData.id);
          }
        });
      }
    };
    return message;
  }

  function handleMessage(messageData) {
    if (messageData.responseId && responseResolver.has(messageData.responseId)) {
      if (debug) {
        log(ownId, "handleMessage() having response id", messageData);
      }

      var resolver = responseResolver.get(messageData.responseId);
      clearTimeout(resolver.timer);
      resolver.resolve(messageData);
      responseResolver["delete"](messageData.responseId);
    } else {
      var message = createMessage(messageData);

      if (listeners.has(message.namespace)) {
        if (debug) {
          log(ownId, "handleMessage() received message having namespace listeners", messageData);
        }

        listeners.get(message.namespace).forEach(function (listener) {
          if (typeof listener == "function") {
            listener(createMessage(message));
          } else if (listener) {
            console.error("Listener is no function: ", listener);
          }
        });
      } else {
        if (debug) {
          log(ownId, "handleMessage() received message without listeners, put into outstanding messages queue", messageData);
        }

        if (!outstandingMessages.has(message.namespace)) {
          outstandingMessages.set(message.namespace, new Set());
        }

        outstandingMessages.get(message.namespace).add(createMessage(message));
      }
    }
  }

  var ownWindow = sourceWindow || window;
  ownWindow.addEventListener("message", function messageListener(event) {
    var data;

    try {
      data = JSON.parse(event.data);
    } catch (error) {
      return false;
    }

    if (!isSafeMessage(event.source, event.origin, data.type)) {
      return false;
    }

    if (data.handshake || data.handshakeConfirmation) return handleHandshake(data);
    return handleMessage(data);
  }, false);
  sendHandshake();

  function hasHandshake(callback) {
    if (isHandshaken) {
      if (typeof callback == "function") {
        callback();
      }

      return true;
    }

    if (typeof callback == "function") {
      handshakeCallback.add(callback);
    }

    return false;
  }

  return {
    addListener: function addListener(namespace, callback) {
      if (debug) {
        log(ownId, "addListener() to " + namespace);
      }

      if (!listeners.has(namespace)) {
        listeners.set(namespace, new Set());
      }

      listeners.get(namespace).add(callback);

      if (outstandingMessages.has(namespace)) {
        if (debug) {
          log(ownId, " \\- has " + outstandingMessages.get(namespace).length + " outstanding messages");
        }

        outstandingMessages.get(namespace).forEach(function (message) {
          return callback(message);
        });
        outstandingMessages["delete"](namespace);
      }

      return callback;
    },
    removeListener: function removeListener(namespace, callback) {
      if (debug) {
        log(ownId, "removeListener() to " + namespace);
      }

      listeners.get(namespace)["delete"](callback);
    },
    send: send,
    hasHandshake: hasHandshake
  };
}

module.exports = interframe;
//# sourceMappingURL=interframe.commonjs.js.map
